# 智能指针

# 函数引用形参什么时候应该是常量引用？如果设置成了普通引用有什么缺点？
我们应该尽量使用常量引用。把函数中不会改变的形参定义成普通引用是不好的。不能接受字面量，无法接受非常量引用。

# 数组传参
当我们向一个函数传递一个数组的时候，实际上传递的是一个指向数据首元素的指针。并且我们需要管理好数组越界问题，因为我们无法传递给函数，数组的长度信息。

数组引用传参是可以得到数据的大小信息的。`void f(int (&arr)[10])`。但是这样也只能接受大小为10的数组。

# 什么是顶层const和底层const
顶层const和底层const都是针对与指针来说的。 指针本身是不是常量以及指针所指的是不是常量这是两个互相独立的问题。

更一般的，顶层const可以表示任意的对象是常量。底层const一般是指针和引用的复合类型有关。

顶层：表示指针本身是一个常量。  const的变量
底层：表示指针所指向的对象是一个常量。 const类型的指针和引用

```c++
int i = 0;
int *const p1 = &i; // 常量p1的指针，指向一个int类型。不能改变p1的值，是一个顶层const
const int ci = 43 // 常量ci，不能修改ci，顶层
const int *p2 = &ci // 常量指针，p2指向的值不能修改，但是其对象可以修改。因此是底层
const int *const p3 = p2 // 指向int常量的常量指针。左侧const是顶层，右侧是底层
const int &r = ci // 常量引用，引用的绑定关系不可以吧，对象可以边，底层
```

当执行拷贝操作时候，两者区别明显。对于底层const，可以从非常量转换为常量，不能从常量变成非常量。（加限制可以）


const是希望定义一个变量，这个变量的值不被改变。const必须初始化。

- const的引用：把引用绑定到常量上。`const int &r = ci` 对常量的引用不能被用作修改它所绑定的对象。**常量引用仅对引用可参与的操作做出了限定，对引用本身是不是常量并无限定**。比如不可以修改r的值，但是可以修改i的值从而修改了r的值。

# 第六章 函数
## 分离式编译
## 传参
1. 普通传参都是拷贝
2. 数组传参会转化为一个头指针，需要自己维护好size等信息。二维数组更是。
3. 引用传参传递的是引用，函数内部的修改可以改变传入的值。
4. 如果函数内不设计修改传入的参数，那么应该尽量传入一个常量引用。因为常量引用可以接受普通引用的传参，反过来则不行。
5. 函数也可以作为一个指针。
6. 