- [什么是操作系统？](#什么是操作系统)
  - [系统调用(用户空间和内核空间)](#系统调用用户空间和内核空间)
  - [线程和进程的区别](#线程和进程的区别)
    - [进程的状态](#进程的状态)
      - [进程的通信的状态](#进程的通信的状态)
      - [进程同步](#进程同步)
    - [线程之间通信](#线程之间通信)
    - [同步机制的原则](#同步机制的原则)
  - [进程调度算法](#进程调度算法)
  - [协程机制](#协程机制)
  - [select，poll，epoll](#selectpollepoll)
  - [fork函数](#fork函数)
  - [并发 vs. 并行](#并发-vs-并行)
  - [异步 vs. 同步](#异步-vs-同步)
  - [非阻塞 vs. 阻塞](#非阻塞-vs-阻塞)
- [内存管理](#内存管理)
  - [页式内存管理](#页式内存管理)
  - [逻辑地址,物理地址,虚拟地址,线性地址](#逻辑地址物理地址虚拟地址线性地址)
    - [地址转换流程](#地址转换流程)
- [虚拟内存](#虚拟内存)
  - [物理内存，虚拟内存，共享内存](#物理内存虚拟内存共享内存)
  - [虚拟内存的实现](#虚拟内存的实现)
    - [请求分页与分页存储的区别](#请求分页与分页存储的区别)
  - [页面置换算法](#页面置换算法)
  - [孤儿进程](#孤儿进程)
  - [僵尸进程](#僵尸进程)
- [死锁问题](#死锁问题)
  - [产生死锁的条件](#产生死锁的条件)
  - [解决策略](#解决策略)
- [Linux系统](#linux系统)
  - [分区与文件系统](#分区与文件系统)
    - [文件读取](#文件读取)
    - [日志](#日志)
  - [软连接和硬链接的区别](#软连接和硬链接的区别)
    - [mv,cp,rm对inode的影响](#mvcprm对inode的影响)
  - [基本操作](#基本操作)
  - [程序后台运行](#程序后台运行)
  - [文件系统](#文件系统)
  - [文件属性](#文件属性)
    - [看懂属性](#看懂属性)
    - [修改属性](#修改属性)
  - [文件内容查看](#文件内容查看)
    - [vim](#vim)
  - [进程查看](#进程查看)
  
# 什么是操作系统？
管理计算机的硬件与软件资源。屏蔽了硬件层的复杂性，操作系统的内核是操作系统的核心，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。

系统的特征：并发，共享，虚拟，异步
## 系统调用(用户空间和内核空间)
根据进程访问资源的特点，可以把进程在系统的运行分为两个等级：
  1. 用户态：用户态运行的进程可以直接读取用户程序的数据。
  2. 系统态：可以简单的理解**系统态**运行的进程或程序几乎可以访问计算机的任何资源，不受限制。


在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

 * 设备管理。完成设备的请求或释放，以及设备启动等功能。
 * 文件管理。完成文件的读、写、创建及删除等功能。
 *   进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
  *  进程通信。完成进程之间的消息传递或信号传递等功能。
   * 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

当需要系统调用,或者遇到异常时候会从用户态切换到内核态.
>系统调用、软中断和硬件中断
## 线程和进程的区别
**线程是进程划分成的更小的运行单位**, 一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

**进程是资源分配的基本单位，线程是独立调度的基本单位。**

两者的区别体现在： 
1. 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，**在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。**
4. 通信：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC(Inter-Process Communication)
5. 多进程程序更健壮， **多线程程序只要有一个线程死掉，整个进程也死掉了**，而一个 进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

### 进程的状态
5种状态
- 创建状态(new) ：进程正在被创建，尚未到就绪状态。
- 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- 运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

#### 进程的通信的状态
常见的有7种

  * 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
  * 命名管道(Names Pipes) : 有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。
  * 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。先进先出。与管道不同的是消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势
  * 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
  * 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
  * 套接字(Sockets) : 此方法主要用于在**客户端和服务器之间通过网络进行通信**。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点
  * 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
#### 进程同步
进程同步与进程通信很容易混淆，它们的区别在于：

  进程同步：控制多个进程按一定顺序执行；

  进程通信：进程间传输信息。

**进程通信是一种手段，而进程同步是一种目的**。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

1. 临界区：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。检查能否进入临界区。
2. 同步与互斥
  - 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
  - 互斥：多个进程在同一时刻只有一个进程能进入临界区。

3. 信号量：是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。
  - down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
  - up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

4. 管程：使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

  
### 线程之间通信
线程之间的通信只是为了对线程共享的区域进行保护和协调。

互斥量：保证公共资源只有一个线程可以访问到；
信号量:可以同一时间多个线程访问同一资源，但控制最大数量；
事件（wait/notify），保证线程的执行顺序。

### 同步机制的原则
线程之间的同步机制是在多线程（进程）的环境下，为了保证多个线程之间可以相互配合的正确完成某项任务，指定的一些策略。主要是对临界区的一些保护。包括四个方面 ：
- 空闲让进：如果目前临界区没有线程，允许线程的进入访问。
- 忙则等待：如果临界区的访问线程数量达到了一定的限制，就不允许新的线程加入。只能等待
- 优先等待：保证在一定的时间内可以得到资源，不会死等。
- 让权等待：当线程无法进入临界区，应当释放自己的资源，防止死锁。


## 进程调度算法
>批处理策略：目标的提高吞吐量，适合计算密集型。

1. 先到先得：从就绪队列中选择一个就绪的进程给他分配资源，这些进程都是被分配资源会一直运行，直到完成或者被阻塞。
2. 短作业优先：从就绪队列中选择一个预估时间短的进程，这些进程都是被分配资源会一直运行，直到完成或者被阻塞。
3. 最短剩余时间优先：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

>交互式策略：交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。IO密集
1. 时间片轮转：每个进程都被分配一个时间片段，是这个进程允许执行的时间。
2. 优先级调度：为每个流程分配优先级。高优先级的先进行。
3. 多级反馈：复合的算法，时间片轮转调度算法和优先级调度算法的结合。
  
## 协程机制
协程机制在lua中有使用到，并且nginx的master-worker模型也有类似的思想。
*  基于用户态模拟出来的独立的运行空间,而完全是由程序所控制；
*  协程依附于**线程的内存模型**，切换开销小；
*  协程遇到**阻塞就归还执行权限**，协程的代码以**完全同步的方式模拟异步的调用**，编程很容易；
* 协程本质上是在线程中串行执行的，对任何共享变量的访问**无需加锁**；
## select，poll，epoll

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315103003323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70)

首先我们需要清楚，有5中IO模型。我们一般讨论的都是IO多路复用的方法。

https://www.cnblogs.com/aspirant/p/9166944.html

select，poll都是采用轮询，epoll是回调，只要判断队列中有没有可以读写的任务即可。

select每次都要把全部的IO句柄复制到内核，句柄的最大数量是1024，句柄越多性能越差，poll模型只是升级了句柄的数量。

epoll： 每次新建IO句柄(epoll_create)才复制并注册(epoll_register)到内核。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。 内核根据IO事件，把准备好的IO句柄放到就绪队列。应用只要轮询(epoll_wait)就绪队列，然后去读取数据。只需要轮询就绪队列（数量少），不存在select的轮询，也没有内核的轮询，不需要多次复制所有的IO句柄。因此，可以同时支持的IO句柄数轻松过百万。

## fork函数
在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
1. 在父进程中，fork返回新创建子进程的进程ID；
2. 在子进程中，fork返回0；
2. 如果出现错误，fork返回一个负值；

## 并发 vs. 并行
并发和并行是相关的定义，有一些微小的不同。
- 并发 指的是两个或多个任务都有进展，即使他们没有被同时执行。例如可以这样实现：**划分出时间片，几个任务交叉执行**，尽管时间片的执行是线性的。
- 并行 则是指可以真正同时执行。

## 异步 vs. 同步
一个方法调用是 同步 的，当调用者不能继续处理，**除非方法返回一个值或抛出一个异常**。

另一方面，一个 异步 调用允许调用者在调用方法的有限步后能够继续执行，并且该方法的结束可以被额外的机制通知到（也许是一个注册的回调callback，一个Future或一个消息）。

一个同步的API也许会使用阻塞实现同步性，但也不是必须的。一个CPU极为密集的任务也会导致类似阻塞的行为。通常推荐使用非阻塞API，因为它们能确保系统继续处理。

## 非阻塞 vs. 阻塞
- 阻塞： **一个线程的延迟会导致其它一些线程无限期的延迟**。一个很好的例子是资源可以被线程通过互斥锁独占。如果这个线程无限期地占有这个资源（例如不小心进入死循环），其他等待这个资源的线程就无法处理了。
- 非阻塞 意味着没有线程可以无限期的阻塞其他线程。

相比阻塞操作，我们推荐非阻塞的操作，因为很明显这样系统不会因为阻塞操作而不再继续处理。

# 内存管理
内存的管理主要负责内存的分配和回收以及将逻辑地址转换成相应的物理地址。

常见的内存管理机制：
简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。
 * 分块管理 ： 将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
 * 分页管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。**页式管理通过页表对应逻辑地址和物理地址。**
 * 分段管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址
 * 段页式管理机制: 段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把**主存先分成若干段，每个段又分成若干页**，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。

> 分页和分段的区别：
分页和分段都是为了解决内存碎片问题。两者都是离散存储的，内部是连续的。区别在于页的大小是固定的，是操作系统决定的；段的大小取决于程序。

>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。
## 页式内存管理
分页机制的思想是: 通过映射，可以使逻辑上连续的线性地址对应的物理地址可以不连续。 

分页的作用 
- 将线性地址转换为物理地址 
- 用大小相同的页替换大小不同的段。

**逻辑地址 = 页号 + 页内偏移量**
取到页号之后，查询页表，得到块号，然后在内存中通过块号&页内偏移量得到最终的物理地址

采用**快表**解决了从虚拟地址到物理地址的转换。快表相当于一个高速cache。类似redis。

采用**多级页表**解决了虚拟地址太大导致页表大，分成了多个页表。

## 逻辑地址,物理地址,虚拟地址,线性地址
- 物理地址：真正的存储的物理的地址，与地址总线相对应。
- 虚拟地址：对应的是虚拟内存中的地址。对应了给进程分配的虚拟内存中的地址。
- 逻辑地址：基于段式内存管理。指定一个操作数或者一个之指令的地址。具体就是 段标识符：段内偏移量
- 线性地址：对应了页式存储的转换前的地址。


虚拟（逻辑）地址是操作系统决定的。而物理地址是真实的地址，是内存地址寄存器的地址。

程序里面都是操作的虚拟地址，这样保证了不同的程序之间的隔离。不会对操作系统造成伤害。程序可以使用一系列连续的虚拟地址访问物理内存种不连续的大内存缓冲区。并且可以访问大于物理内存的空间，只是这些空间在磁盘上。
### 地址转换流程
首先 对于段式内存管理，将逻辑地址转换成一个线性地址。如果式页式管理，线性地址转换为物理地址。

# 虚拟内存
虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。

**时间局部性原理**认为，某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。
时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “**内存-外存**”的两级存储器的结构，利用局部性原理实现髙速缓存。

## 物理内存，虚拟内存，共享内存
物理内存（RES）是系统的真实内存。除去内核使用的部分，所有的进程都需要分配物理内存页给他们存放代码、数据和堆栈。进程消耗的这些物理内存成为“驻留内存”，RSS。除了内核和进程使用的部分，剩下的物理内存就是页缓存，可以配合请求置换。

虚拟内存（VIRT）其实并存在，就是一种映射技术，将内存扩大到了磁盘空间。寻址时候借助的页表，将虚拟地址转换成物理地址。

共享内存（SHR），在程序运行中进程可以公用的部分。在内存中只加载一份。这部分也是计算在驻留内存的。

## 虚拟内存的实现
虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。

核心就是三个对应的方法。


  * 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了**请求调页功能**和**页面置换功能**。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
  * 请求分段存储管理 ：建立在分段存储管理之上，增加了请求**调段功能**、**分段置换功能**。
  * 请求段页式存储管理

### 请求分页与分页存储的区别
分页存储，是在内存中进行分配。也就是无法使用磁盘。

而请求分页是为了提供虚拟内存，使用了磁盘空间，并不是完全加载到内存中。

根本区别在于**是否将程序的全部地址空间同时装入主存**。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。

## 页面置换算法
缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断。此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。


在发生请求的页不存在时候，需要从内存值读取，如果内存满了就需要置换一下。

  * OPT 页面置换算法（最佳页面置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。
  * FIFO页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
  * LRU页面置换算法（最近最久未使用页面置换算法） ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。**实现LRU使用的是hashmap+双向链表**。一个页面被访问后就会被放置到队列头。
  * LFU页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。


## 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

## 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

# 死锁问题

## 产生死锁的条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程不会释放资源并且可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 解决策略
死锁的解决方案就是从产生死锁的必要条件入手，如果不满足必要条件，那么就失去了发生死锁的可能性。还是以线程为例，给出死锁的解决方案：

1. 破坏请求条件：一次性给线程分配所有的资源，例如上述案例直接给线程 A 分配锁 a 和锁 b。
2. 破坏保持条件：只要存在任何一个资源不能被分配，已有被分配的资源也不能保持。例如上述案例中线程 A 不能获得锁 b，那么需要主动释放锁 a。
3. 破坏不可剥夺条件：只要存在任何一个资源不能被分配，已有被分配的资源可以被强制释放。
4. 破坏循环等待条件：所有的线程按照提前指定的顺序请求资源，释放资源的顺序刚好相反。

避免死锁的经典算法有银行家算法，我们把操作系统比喻成银行家，操作系统管理的资源就是银行中的资金，进程（线程）就是顾客，获取资源的过程就是向银行家索要贷款的过程，线程在获取资源前需要申明自己需要的每种资源的最大数量，操作系统计算在分配这些资源之后，是否会让系统处于不安全的状态。总结来看，银行家算法是一个动态判断死锁的算法。



鸵鸟策略：等到遇到在进行处理。
死锁检测与主动放弃资源：在检测到请求锁资源迟迟无法被满足以后，有一方主动释放资源。回滚。
死锁预防：银行家算法，一次性给与需要的全部资源，使用后再收回。破坏环路等待等。
# Linux系统
## 分区与文件系统

对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。
组成

最主要的几个组成部分如下：

- inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；
- block：记录文件的内容，文件太大时，会占用多个 block。

- superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；
- block bitmap：记录 block 是否被使用的位图。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210311211259103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70)

一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。

inode 具体包含以下信息：

- 权限 (read/write/excute)；
- 拥有者与群组 (owner/group)；
- 容量；
- 建立或状态改变的时间 (ctime)；
- 最近读取时间 (atime)；
- 最近修改时间 (mtime)；
- 定义文件特性的旗标 (flag)，如 SetUID...；
- 该文件真正内容的指向 (pointer)。

inode 具有以下特点：

1. 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；
2. 每个文件都仅会占用一个 inode。

**inode 中记录了文件内容所在的 block 编号，**但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。

### 文件读取

对于 FAT 文件系统，它没有 inode，**每个 block 中存储着下一个 block 的编号**。对于 Ext2 文件系统，当要读取一个文件的内容时，**先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。**

* 磁盘碎片：
指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。

### 日志

如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。

## 软连接和硬链接的区别
```
## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
```


* 软连接：A是B的软连接，A的目录项中的inode节点号与B的目录项中的inode节点号不同。**A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的是B的路径名，从而可以找到B的目录项**。可以为目录建立符号连接。当源文件被删除了，链接文件就打不开了。
* 硬链接：A是B的硬链接。A的目录项中的inode节点号与B的目录项的innode节点号相同，也就是**一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对于文件系统是平等的**。不能跨越文件系统、不能对目录进行连接。在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。
### mv,cp,rm对inode的影响
>cp对inode的影响：
1. 当复制行为发生的时候，系统会找到一个空inode number，然后将数据写入到inode table 
2. 并且会新增一个目录，把文件的档案名称对应到inode number 
3. 当inode number和inode table处理好了之后，系统才会将文件内容复制到新增的文件中 
 
>mv对inode的影响：
前提：使用mv命令搬移的文件目的地跟原文件在同一文件系统内

1. 系统会新建一个目录项，将新档案名称对应到inode number 
2. 删除旧档案（搬移档案的行为对inode table没有任何影响，也不会将档案搬移到其他的block）

>rm对inode的影响：

1. 系统会减去文件的link count数字，然后将对应的inode number标记为可使用	
2. 而文件所占用的block也会打上可以使用的“标签”
3. 最后移除文件名称和目录项
## 基本操作
* 进入：`cd` 展示：`ls` 展示全部：`ls -a` 展示属性:`ls -l`  可以`cd ..`表示退出到父目录，`cd dir1`进入当前目录是相对路径, `cd /usr`可以任意地方使用，进入绝对路径。正常连接系统都是进入了/root 路径下。我们可cd .. 回到主目录。
* 创建文件夹：`mkdir name`   递归创建目录：`mkdir -p 1/2/3` 指定目录的权限：`mkdir -m 711 test2`
* 移动文件夹：`mv dir1 dir2 ` 将dir1移动到dir2里面  如果没有文件夹，其实相当于重命名
* 删除文件或者目录一般使用：`rm -rf dir_name`这样可以递归的删除文件夹内的全部东西，采用`rm -i name`可以在删除前依次进行询问
* 复制：`cp dir_source dir_target` 这个也可以有一定的参数`-r -f  -i`递归，强制，覆盖前询问
* touch file 创建一个名字为file的文件 
* pwd 查看当前位置
* clear 清屏
* `kill -p name`直接可以强制结束一些进程。
* 磁盘查看`df -h`  df：显示磁盘分区上可以使用的磁盘空间
* 查看当前磁盘最大的10个文件 `du -a | sort -nr | head -n 10`
du : 显示每个文件和目录的磁盘使用空间~~~文件的大小。
free  可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。
* rpm类型的文件 `rpm -ivh filename`
* tar.gz类型的文件 ` tar -zxvf`
* yum下载 `yum -y install name`
* `top -H`查看当前的cpu使用情况
* `wget`从网络上下载
* `netstat -an | grep 80` 查看相关的端口。


面经: Linux命令：查看文件中某个字段出现的次数 `grep -o objStr filename|wc -l`
## 程序后台运行
`nohup java -jar xxx.java &`这个方法可以保证后台运行。nohup是指no hangup，在用户退出以后也可以继续执行。&是在后台执行，但当用户推出(挂起)的时候，命令自动也跟着退出。因此需要配合使用。


## 文件系统
以下是对这些目录的解释：
* ==/bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。==
* /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。
*  /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
*    ==/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。==(基础的环境变量在这里/etc/profile)
*   /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。
*   /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。
*   /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
 *   /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。
 *  /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。
 *  /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。
*    /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
 *   ==/root：该目录为系统管理员，也称作超级权限者的用户主目录。==(刚开机在这个目录里)
  *  /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
   * /srv：该目录存放一些服务启动之后需要提取的数据。
   * /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。
 *   /tmp：这个目录是用来存放一些临时文件的。**比如安装包**
  *  ==/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。==
    /usr/bin： 系统用户使用的应用程序。
    /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。
    /usr/src： 内核源代码默认的放置目录。
  *  /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。
   * /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。
   * /www：这个目录也常看，是存放网站资源相关的东西


经常使用的就是/usr目录，和/www目录。

## 文件属性
### 看懂属性
首先第一个字母代表这个文件是目录、文件还是链接文件等
* d表示目录
* -是文件
* l为链接文档，b是随机存取装置，c是串行端口

接下来的字母三个一组是rwx的组合。没有权限就是-号。分别是属主权限，属组权限和其他用户权限。表示拥有者，拥有者的用户组的用户，和其他。

### 修改属性
* chgrp：更改文件属组 `chgrp [-R] 属组名 文件名`  -R表示递归更改全部 可选
* chown: 更改文件属主`chown [–R] 属主名 文件名`
* chmod: 更改文件权限 `chmod [-R] xyz 文件或目录`  这里的xyz表示三个部分的权限，r=4,w=2,x=1（二进制）因此就是` chmod 777 filename`这就表示赋予全部权限。

## 文件内容查看
* cat 由第一行开始显示文件内容
* tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
* nl  显示的时候，顺道输出行号！
* more 一页一页的显示文件内容 这个也比较常用，可以查找内容`/字符串`向下寻找，`?字符串`向上寻找，n继续，N向上继续
* less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
* head 只看头几行
* tail 只看尾巴几行  很常用的是`tail -f filename`这样可以查看刷新中的页面 `tail -n 10 filename`可以查看最后10行。

### vim
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210223203905303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70)


常用的也就是`:wq`保存退出，/file查找，:set nu查找对应的行号。
## 进程查看
`ps` 查看当前系统中正在执行的各种进程信息！

`ps -xx`:
* -a :查看终端全部进程
* -u：以用户信息显示进程
* -x：显示后台线程参数
* `ps -aux | grep java`

常用的有一个管道符号`|`，将前面的得到的信息进一步操作，并且过滤`grep`。可以查看相关的进程信息`ps -ef | grep java`这个方法可以查找到父进程的信息。

查看父进程的还一个方法就是`pstree -x`后面跟参数`-p  -u` 显示父id， 显示用户组。这样可以得到进程树。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210223211517851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70)


