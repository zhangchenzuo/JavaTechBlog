- [JVM内存分配](#jvm内存分配)
  - [JVM简化架构](#jvm简化架构)
    - [Java堆](#java堆)
    - [方法区(也可以称为元空间/永久代)](#方法区也可以称为元空间永久代)
    - [虚拟机栈](#虚拟机栈)
    - [本地方法栈](#本地方法栈)
    - [程序计数器：](#程序计数器)
  - [对象的访问定位](#对象的访问定位)
  - [创建新对象的内存分配流程](#创建新对象的内存分配流程)
- [垃圾回收基础](#垃圾回收基础)
  - [引用计数法](#引用计数法)
  - [可达性分析法（根搜索法）](#可达性分析法根搜索法)
  - [引用分类](#引用分类)
  - [判断垃圾的步骤](#判断垃圾的步骤)
- [GC类型](#gc类型)
  - [跨代引用](#跨代引用)
  - [垃圾收集类型：](#垃圾收集类型)
  - [垃圾收集算法](#垃圾收集算法)
    - [基础算法](#基础算法)
    - [分配担保](#分配担保)
  - [堆外内存的回收](#堆外内存的回收)
- [HotSpot收集器](#hotspot收集器)
  - [Serial 串行收集器](#serial-串行收集器)
  - [ParNew 并行收集器](#parnew-并行收集器)
  - [Parallel Scavenge收集器/Parallel Old](#parallel-scavenge收集器parallel-old)
  - [CMS收集器（并发收集器）](#cms收集器并发收集器)
  - [G1收集器](#g1收集器)
  - [其他收集器](#其他收集器)
  - [GC的选择](#gc的选择)
  - [内存分配策略](#内存分配策略)
  - [GC性能与参数设置](#gc性能与参数设置)
    - [Q: GC等待时间过长怎么优化？](#q-gc等待时间过长怎么优化)
- [类加载机制](#类加载机制)
  - [类的生命周期](#类的生命周期)
  - [加载](#加载)
  - [验证、准备、解析](#验证准备解析)
  - [初始化](#初始化)
    - [类初始化：](#类初始化)
    - [接口初始化：](#接口初始化)
  - [卸载](#卸载)
- [类加载器](#类加载器)
  - [双亲委派模型](#双亲委派模型)
    - [定义](#定义)
    - [代码实现：](#代码实现)
      - [命名空间](#命名空间)
    - [破坏双亲委派](#破坏双亲委派)
- [JMM与内存交互](#jmm与内存交互)
  - [内存交互](#内存交互)
  - [可见性、重排序、原子性](#可见性重排序原子性)
    - [线程安全](#线程安全)
  - [其他](#其他)
    - [对象的创建过程](#对象的创建过程)
  - [类文件的结构](#类文件的结构)
  - [java是如何实现跨平台](#java是如何实现跨平台)
    - [字节码和源代码的区别](#字节码和源代码的区别)
  - [内存泄漏](#内存泄漏)
    - [可能的原因](#可能的原因)
 

# JVM内存分配

## JVM简化架构
Q:介绍下 Java 内存区域（运行时数据区）?

JVM中内存分为五个主要的部分：堆，方法区  虚拟机栈，本地方法栈，程序计数器

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200920201056367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)


>线程共享
### Java堆

存放对象实例和数组实例。GC主要操作的区域，因此被分为新生代与老年代
- 分配对象的方法：指针碰撞和空闲列表，主要针对规整的空间的GC和不规整的需要额外维护一个空闲列表。
- 堆上变量的访问方法：句柄法和直接指针法。 
- 存在OOM。
- Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可

Java世界里“几乎”所有的对象实例都在这里分配内存。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

优点：运行期动态分配内存，自动CG。
缺点：效率低

> Java堆的参数
* -Xms10m：初始堆的大小，大于1MB且1024的倍数。默认物理内存的1/64
* -Xmx20m: 最大堆大小，默认物理内存的1/4
* -xmn：新生代大小，默认整个堆的3/8


### 方法区(也可以称为元空间/永久代)

存储已被**虚拟机加载的类信息、常量、静态变量、运行时常量池**和即时编译器编译后的代码缓存等数据。对这一区域而言一般不会进行垃圾回收。 
 
*  运行时常量池：方法区的一部分。存放编译期生成的各种**字面量**与**符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。
  

 符号引用: 类名、字段、方法、接口等。
 
 字面量: 字符串,八种基本类型,被声明为final的常量. 


在jdk1.8中,将方法区改为了元空间,并且移动到了本地内存中而不是虚拟机中。并且将字符串常量池拿到了堆中,运行时常量池依然保存在方法区也就是元空间中。这样可以使用的空间更大。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。

>线程私有


### 虚拟机栈

虚拟机栈是Java方法执行的内存模型。栈由一系列栈帧构成，方法执行时会创建栈帧,用来保存一个方法的**局部变量表、操作数栈**、动态连接、方法出口。可能出现OOM和SOF(爆栈)

其中局部变量表包括了**基本数据类型、对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

每次方法调用，都创建一个帧并压栈，退出方法就弹栈。

存储快速，但是空间小。

### 本地方法栈
支持native方法的栈。 

### 程序计数器：

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

作用：存储下一条指令的地址；创建：创建线程时候创建，因此是线程私有的

执行本地（native）方法时，程序计数器为空（Undefined）。比较小的内存空间，虚拟机中唯一没有规定OOM的区域。

> 交互关系
栈里面只是指针，指向堆中对象的**user实例和user类的元数据信息**，元数据信息指向方法区对应的user类的类定义，字段，方法。


## 对象的访问定位
程序会通过栈上的reference数据来操作堆上的具体对象。因此这里需要一个指向对象的引用。两种：**使用句柄或者直接指针。**

* 使用句柄：如果使用句柄访问的话，**Java堆**中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的**句柄地址**，而句柄中包含了**对象实例数据与类型数据各自具体的地址信息**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020092020424694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

* 直接指针：reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200920204254203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)


* 方法对比：

直接方法更快速，hotSpot使用；句柄方法更安全，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

## 创建新对象的内存分配流程
![在这里插入图片描述](https://img-blog.csdnimg.cn/b6f5072485c945f0ab85bd6395d97522.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAemN6NTU2NjcxOQ==,size_20,color_FFFFFF,t_70,g_se,x_16)


1. 绝大部分对象在 Eden 区生成，当 Eden 区装填满的时候，会触发 Young Garbage Collection，即 YGC。
2. 垃圾回收的时候，在 Eden 区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到 Survivor 区。
3. Survivor 区分为 so 和 s1 两块内存空间。每次 YGC 的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。
4. 如果 YGC 要移送的对象大于 Survivor 区容量的上限，则直接移交给老年代（分配担保）。
5. 在多次垃圾回收后，仍然存活的对象会被晋升到老年代。在 JVM 中 －XX:MaxTenuringThreshold 参数就是来配置一个对象从新生代晋升到老年代的阈值。默认值是 15，可以在 Survivor 区交换 14 次之后，晋升至老年代。
6. 老年代中的垃圾回收称为Major GC或Full GC，它是对整个堆内存进行回收的过程。Major GC的触发条件可以是老年代空间不足、显式调用System.gc()等。
# 垃圾回收基础
* 什么是垃圾：内存中不在被使用到的内存空间就是垃圾。

>如何判断对象死亡
## 引用计数法
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

* 优点：实现简单、效率高；
* 缺点：**不能解决对象之间的循环引用**。

## 可达性分析法（根搜索法）
通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。

* 能够作为GCroots的对象：
在虚拟机栈（栈帧局部变量表）中引用的对象、方法区类静态属性的引用对象、方法区中常量引用的对象、本地方法栈中引用的对象。

* 具体实现上的优化

1. HotSpot中使用了**OopMap**的结构，保证准确快速完成GCroot的枚举。并且为了防止引用关系发生变化，设置了**安全点**，在安全点上进行记录和GC操作。到达安全点的方法也可以分为**抢先式中断和主动式中断**。抢先式式全部暂停，没有到达安全点的继续运行一下，这个方法几乎不被使用。主动式设置了标志位，在每个安全点出都查询标志位。并且还要检查Java堆的大小，确认是否有足够的内存分配资源。另外，存在**安全区域**，保证代码在这段区域中，引用关系不会变化。

2. **记忆集**：用于记录从**非收集区域**指向**收集区域**的**指针集合**的抽象数据结构。记录跨代引用的情况。具体实现，卡表法。

3. 写屏障：维护卡表状态。在引用类型字段赋值前后，执行写屏障，更新卡表。

## 引用分类
**强软弱虚**

* 强引用(永不)：类似Object a = new A(）无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。

* 软引用(迫不得已)：还有用但是并不必须。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常。

* 弱引用(下次一定)：非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
 
* 虚引用(我知道了)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知


## 判断垃圾的步骤

* 实例垃圾
1. 根搜索算法判断不可用
2. 看看是否有必要执行finalize方法，只有第一次被回收时执行。
3. 两个步骤完成没人使用，属于垃圾。进行垃圾回收。

* 类垃圾（同时满足）
4. JVM中该类的全部实例被回收
5. 加载该类的CLassLoader被回收
6. 没有任何地方引用该类的Class对象，无法在任何地方通过反射访问这个类

可以进行类的卸载。

# GC类型
* Minor GC：发生在新生代的GC(young GC)  **复制清除**
* MajorGC：发生在老年代的GC    **标记整理**
* MixedGC：发生在新生代和部分老年代，G1
* FullGC：收集整个Java堆和方法区的GC

尽量减少Stop-the-world的时间。

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：
1. System.gc()方法的调用【此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定】
2. 老年代空间不足
3. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
4. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
5. 方法区空间不足

## 跨代引用
* 什么是跨代引用： 一个代的对象引用其他代中的对象。老年代中的对象引用新生代的对象。
* 跨代引用假设：跨代引用相对于同代引用对象是极少数。
* 隐含推论：相互引用关系的两个对象，倾向于同时生存或者同时消亡。
* 优化解决方法：记忆集。
  
## 垃圾收集类型：
* 串行收集：GC单线程内存回收，暂停所有用户进程  Serial
* 并行收集：多个GC线程并发工作，但是还是会暂停用户线程  Parallel
* 并发收集：用户线程和GC线程同时（不一定并行，可能交替），用户线程不需要停顿。  CMS G1

## 垃圾收集算法
### 基础算法
* 标记清除法：
标记所有垃圾，然后清理。
优点：简单
缺点：执行效率低，一个一个标记；内存空间碎片化


* 标记复制算法：
一份为二，GC时候把存活的对象复制到一边，然后清空半区。**用于回收新生代**，新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。8：1：1。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行**分配担保**。

**缺点**：浪费了一半空间。


* 标记整理法：
让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须STW才能进行。**老年代一般采用**



### 分配担保

在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：
* 如果这个条件成立，那这一次Minor GC可以确保是安全的。
* 如果不成立，则虚拟机会先查看是否允许担保失败；
	* 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
		* 如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；
		* 如果小于，或者不允许冒险，那这时就要改为进行一次Full GC。


## 堆外内存的回收

JDK中使用DirectByteBuffer对象来表示堆外内存，每个DirectByteBuffer对象在初始化时，都会创建一个对用的Cleaner对象，这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存。
![在这里插入图片描述](https://img-blog.csdnimg.cn/21dd231cf19c4acd9a3b0ce606e0db88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70)

相当于存储了一个标签，当不在使用时候，fgc就去收回这个空间。





# HotSpot收集器
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017152928290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

## Serial 串行收集器

是一个**单线程工作**的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，**必须暂停其他所有工作线程，直到它收集结束**。

简单，**所有收集器中额外内存消耗最小的**，**默认client模式下新生代收集器。**  `-XX:+UseSerialGC`开启。**新生代是复制算法，老年代是标记整理算法**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017153034521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)


## ParNew 并行收集器
是Serial收集器的多线程并行版本。服务端Server模式下首选的新生代收集器。和CMS配合。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017153519909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

## Parallel Scavenge收集器/Parallel Old

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的**停顿时间**，而Parallel Scavenge收集器的目标则是达到一个可**控制的吞吐量**。(gc时间/cpu时间)

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，**良好的响应速度能提升用户体验**；而**高吞吐量则可以最高效率地利用处理器资源**，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017153957419.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017154132884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)


##  CMS收集器（并发收集器）
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于标记-清除算法。`-XX:UseConcMarkSwepGC`,使用ParNew+CMS+Serial Old组合。

* 四个阶段：
1. **初始标记**： 只是标记一下GCRoots能直接关联到的对象，速度很快。**需要STW。**
2. **并发标记**：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
3. **重新标记**：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的
标记记录。**STW**
4. **并发清除**：最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程**同时并发**的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017162754658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

* 优缺点：
优点：并发收集、低停顿。
缺点：对处理器资源敏感，并发执行的原因；无法处理浮动垃圾，也是因为并发（并发失败采用Serial old）；空间碎片化，大对象容易FullGC。


## G1收集器
G1是一款主要面向服务端应用的垃圾收集器。**新的服务端模式下的默认GC**。**在延迟可控的情况下获得尽可能高的吞吐量**，但是**G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。**

* 特点：
1. 把连续的Java堆划分为多个大小相等的独立区域（Region）。
2. 保留了分代的思想，但是不再是物理隔离，而是一部分region 的集合。每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。Region中还有一类特殊的Humongous区域，专门用来**存储大对象**。
3. 充分利用多CPU，尽量缩短STW。
4. 整体上是标记整理算法，**局部是复制算法**。不会产生内存碎片。
5. 停顿可预测。每次寻找最多垃圾的region回收，每次收集到的内存空间都是Region大小的整数倍（mixedGC）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017172523916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

* 四个步骤
1. 初始标记：标记一下GC Roots能直接关联到的对象，**STW**
2. 并发标记：GC Root
3. 最终标记：**STW**，最终标记。
4. 筛选回收：在给定的时间内，寻找最大的价值region。**STW**


![在这里插入图片描述](https://img-blog.csdnimg.cn/20201017173326311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

* 使用参数
1. `-XX:+UseG1GC` 开启G1，默认就是G1.
2. `-XX:MaxGCPauseMilis = n` 最大Gc停顿时间。
3. `-XX:InitiatingHeapOccupancyPercet = n` 占用多少空间比例时候，出发GC
4. `-XX:NewRatio = n` 默认为2 新生代和老年的比例
5. `-XX:SurvivorRatio = n` 默认为8  
6. `-XX:MaxTenuringThreshold = n`默认15，新生代到老年代的岁数。

## 其他收集器
* ZGC收集器：暂停时间低；支持Tb级别内存，吞吐量影响下。


## GC的选择
1. 吞吐量优先:新生代使用Parallel scavenge,老年代使用Parallel Old.
2. 响应优先:老年CMS,年轻ParNew



## 内存分配策略
1. 对象，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
2. **大文件直接进入老年代。**
3. **长期存活的对象直接进入老年代**。
4. 动态年龄判断：**如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代**
5. 空间分配担保：在发生Minor GC之前，虚拟机会检查**老年代最大可用的连续空间是否大于新生代所有对象的总空间**，如果大于，则此次Minor GC是安全的；如果小于，会看是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者不可以承担风险，则改为进行一次Full GC。


## GC性能与参数设置
* 吞吐量：代码时间/GC时间。    反过来就是GC负荷
* STW时间
* GC频率：发生GC的次数。
* 反应速度：从对象称为垃圾到被回收的时间
* 低延迟：影响交互的时间最小。

新生代的不能太小，容易导致频繁YGC，且进入老年代之后容易FGC。新生代的大小**是整个堆的3/8到一半**。

老年代要适当，太小容易内存碎片，或者高频率FGC；太大了回收时间长。


* 经验：
1. 新生代的不能太小，容易导致频繁YGC，且进入老年代之后容易FGC。新生代的大小**是整个堆的3/8到一半**。

2. 老年代要适当，太小容易内存碎片，或者高频率FGC；太大了回收时间长。
3. 对于吞吐量优先的应用，设置大新生代和小老年代，尽快回收短期对象。
4. 对象优先再新生代分配，长时间存活对象进入老年代。

合理选择，内存分配，收集器方法。

### Q: GC等待时间过长怎么优化？
可能是新对象创建的比较快且比较多，或者young区太小了。对象过早触发了担保机制，晋升到了old区。一般young是整个堆的3/8。或者选择合适GC算法，G1是可以在给定停顿时间完成的。

# 类加载机制
## 类的生命周期
一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历 **加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading** 七个阶段.前五个比较重要.

其中验证、准备、解析三个部分统称为连接（Linking）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200919210408346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)加载，验证，准备，初始化，卸载这五个阶段的顺序是确定的。这些过程可能是交叉的。

## 加载
1. 通过类的全限定名，查找并加载类文件的二进制数据；

2. 将这个字节流所代表的静态存储结构转化为**方法区**的运行时数据结构；

3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

## 验证、准备、解析
将读入数据合并到JVM内存
1. 验证：确认正确性
2. 准备：为**类的静态变量**分配内存，并初始化。
3. 解析：把常量池的符号引用转换为直接引用。

* 验证：类文件格式检查，元数据验证，字节码验证，符号引用验证。
* 准备：如果一个变量是常量（被 static final 修饰），那么在准备阶段，属性便会被赋予用户希望的值。`public static final int number = 3;`
* 解析：符号引用变成直接引用。
  其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
## 初始化
为类的静态变量赋值，或者说执行类构造器`<clint>`方法。

### 类初始化：
**初始化时机**
1. 创建类实例在new实例化对象，
2. 读取或设置类或者接口的静态字段，
3. 调用类的静态方法。
4. 反射某个类。
5. 如果初始化类式其父类没有被加载要先加载父类。
6. 当虚拟机启动时，要先加载主类。


**被动引用**
* 当子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

* 数组定义引用类，不会触发类的初始化。
* final修饰常量会在编译阶段被存入调用类的常量池，不会触发定义常量的类的初始化
### 接口初始化：
如果是接口：
1. 初始化类时候，不会先初始化它实现的接口
2. 初始化接口时，不会初始化父接口
3. 只有首次使用接口变量或者调用接口方法，才会初始化。延迟加载

## 卸载
当Class对象不再被引用，对应在方法区的数据会被卸载。

# 类加载器
三种加载器：启动类加载器（Bootstrap）、扩展类加载器（Extension）、应用程序类加载器（Application）。或者自定义类加载器。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200919211924592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

## 双亲委派模型
### 定义
除了启动类加载器，都要有自己的父加载器。
双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的**

加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

优点：
1. 保证了安全性，系统类被保护

> 例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。

### 代码实现：

先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。

#### 命名空间
对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：**比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。**

### 破坏双亲委派
* 存在问题：父加载器无法识别子加载器加载的资源。或者热替换。

* 解决办法：引入线程上下文类加载器，通过Thread的setContextClassLoader()设置。如果创建线程时候没有就会从父线程继承；否则就默认是Application加载器。

自定义加载器的话，需要继承 **ClassLoader** 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的` findClass() `方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass() `方法

比如数据的mysql driver。` Connection conn= DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK", "root", "");
`
原生的JDBC中的类是由启动类加载器进行类加载的，在JDBC中的Driver类中需要去加载不同数据库类型的Driver类。而mysql-connector-.jar中的Driver类是用户自己写的代码，由应用程序启动类去进行类加载。于是，引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。


# JMM与内存交互

Java内存模型的主要目的是定义程序中各种变量的访问规则。Java内存模型的意义，在不同的平台上实现读写的一致性。尤其是对于并发问题。**主内存与工作内存的交互。主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。**

* Java内存模型规定了：
1. 所有的变量都存储在主内存中。包括了**实例字段、静态字段和构成数组对象的元素**，但是不包括局部变量与方法参数，因为后者是线程私有的。
2. 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本
3. 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。
4. 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201018160822371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjejU1NjY3MTk=,size_16,color_FFFFFF,t_70#pic_center)

## 内存交互
JVM在实现时能够对一些操作保证原子性（8种）：lock, unlock, read, use, load, assign, store, write.

很多操作具有成对性质且保证顺序，但是不必连续执行。线程不许丢弃最近的assign的操作，同样不许一个变量没有被assign就被传回。一个变量只能从主内存中诞生。对一个变量lock时，会清空工作内存中此内存的值，在unlock之前，需要把变量刷回主内存。

## 可见性、重排序、原子性
volatile关键字，这部分内容可以见并发内容的复习。

8条happens-before：
1. 本线程内操作有序。
2. 锁先后：unlock操作，先于同一个锁的lock
3. 线程启动先后
4. volatile规则
5. 线程终止先后
6. 线程中断先后
7. 对象终结先后
8. 传递性先后

### 线程安全
* 不可变时线程安全的
* 互斥同步时安全的，synchronized和reentrantlock
* 非互斥同步，乐观锁的方法。有冲突就回退。

## 其他
### 对象的创建过程


JVM遇到字节码new之后，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须**先执行相应的类加载过程**。

然后进行**内存分配**，对象所需内存的大小在类加载完成后便可完全确定。两种方法：**指针碰撞和空闲列表**。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定。

可能在分配空间时多线程发生冲突，两个方法：一种是对**分配内存空间的动作进行同步处理**——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲**，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。


最后**内存空间都初始化为零值,设置对象头，执行`<init>`方法。**

1. 类加载检查
2. 分配内存
3. 初始化零值
4. 设置对象头
5. 执行init方法


## 类文件的结构
![](https://camo.githubusercontent.com/4ce39b7a97e0d9ecf749add3c6f0f863840756572bd82c67588dd0650e630ff7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545362539362538372545342542422542362545352541442539372545382538412538322545372541302538312545372542422539332545362539452538342545372542422538342545372542422538372545372541342542412545362538342538462545352539422542452e706e67)



## java是如何实现跨平台
  * Java语言规范   通过规定Java语言中基本数据类型的取值范围和行为
  * Class文件 所有Java文件要编译成统一的Class文件
  * Java虚拟机 通过Java虚拟机将Class文件转成对应平台的二进制文件等 Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。

跨平台，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。

实现跨平台：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。
由源文件(.java)—>字节码文件(.class)(二进制文件)-----> 解释---->Unix,Win,Linux等机器。

1.一次编译，到处运行
2.编译器的作用：将源文件编译成class文件
3.虚拟机的作用：将字节码文件解释成对应平台机器码并执行。
4.java可以实现跨所有的平台？只有提供并且安装了相对应的虚拟机就可以跨该平台。
5.虚拟机和解释器的关系：解释器是虚拟机的一个重要的组成部分。
6.Java语言的执行要经过编译和解释两个阶段

### 字节码和源代码的区别
字节码文件就是以.CLASS文件结尾的文件，是通过JAVAC命令编译过生成的。因为JAVA不是编译型语言，所以它需要去解释字节码文件才能够运行。

源程序是指未编译的按照一定的程序设计语言规范书写的文本文件.还是以Java为例,以.java .c .cpp等结尾的文件.

简单地说.机器执行的是字节码,它不认识源代码,源码必须经编译器编译成字节码之后才能被机器执行. 

## 内存泄漏
内存泄露可以定义为：当一个对象已经不再被应用程序使用以后，它所占用的内存没有得到及时的释放，导致内存使用量随着时间的推移不断的增加，最终导致应用程序崩溃的现象（Java中会在new新对象的时候抛出OutOfMemoryError）。对于Java程序而言，当一个Object已经不会被程序所使用，但是它还被其它对象所引用，从而导致GC的时候无法被回收，从而导致内存泄露。

### 可能的原因
1. 静态集合类引起内存泄漏：定义了静态的hashmap，内部引用了对象，这些对象都是无法被回收的。
2. Threadlocal里面的val就是一个强引用，容易发生内存泄漏。

回收的方法就是及时设置为null；